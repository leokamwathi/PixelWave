[gd_scene load_steps=55 format=2]

[ext_resource path="res://src/levels/Backgrounds.gd" type="Script" id=1]
[ext_resource path="res://assets/backgrounds/cyberpunk-city-night-scenery-sci-fi-uhdpaper.com-4K-94.jpg" type="Texture" id=2]
[ext_resource path="res://assets/backgrounds/991947180.jpg" type="Texture" id=3]
[ext_resource path="res://assets/backgrounds/cyberpunk_nebula.jpg" type="Texture" id=4]
[ext_resource path="res://assets/backgrounds/998938790.jpg" type="Texture" id=5]
[ext_resource path="res://assets/backgrounds/cyberclouds.jpg" type="Texture" id=6]
[ext_resource path="res://assets/backgrounds/cyberclouds2.jpg" type="Texture" id=7]
[ext_resource path="res://src/shaders/warpedSpace.shader" type="Shader" id=8]
[ext_resource path="res://assets/squares/32x32_gray.png" type="Texture" id=9]
[ext_resource path="res://src/shaders/abstractWave.shader" type="Shader" id=10]
[ext_resource path="res://src/shaders/fog.shader" type="Shader" id=11]
[ext_resource path="res://src/levels/ShaderTemplate.gd" type="Script" id=12]
[ext_resource path="res://src/levels/shaderTexture.gd" type="Script" id=13]
[ext_resource path="res://assets/squares/16x16_gray.png" type="Texture" id=14]
[ext_resource path="res://icon.png" type="Texture" id=15]
[ext_resource path="res://assets/squares/32x32_black.png" type="Texture" id=16]
[ext_resource path="res://src/levels/shader_learn.shader" type="Shader" id=17]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;
void fragment()
{
    vec4 col = textureLod(TEXTURE, FRAGCOORD.xy/(1.0 / SCREEN_PIXEL_SIZE).xy, 0.);
    if (FRAGCOORD.y < 1. || FRAGCOORD.y >= ((1.0 / SCREEN_PIXEL_SIZE).y-1.))
        col = vec4(0);
    COLOR = col;
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )

[sub_resource type="ShaderMaterial" id=3]
shader = ExtResource( 8 )
shader_param/tau = 6.28319

[sub_resource type="ShaderMaterial" id=4]
shader = ExtResource( 10 )
shader_param/WEBN = 50.0

[sub_resource type="Shader" id=5]
code = "shader_type canvas_item;

uniform float PI = 3.14;
void fragment()
{
    float scale = 5.0;
    float i = TIME*.5;
    vec4 o = vec4(0.0);
	vec2 uv = FRAGCOORD.xy / (1.0/SCREEN_PIXEL_SIZE).xy*scale;
    uv-= scale*0.5;
    
    mat2 m = mat2(vec2(cos(uv.x-i),sin(sin(uv.x)+i)),vec2(cos(uv.y+i),cos(uv.y-i*.5)));
    uv = uv*m;
    
    float dist = length(uv);
    float a = atan(uv.y,uv.x);
    o.r = mod(dist,1.0);
    o.g = mod(a,0.5)*2.0;
    o.b = mod(uv.x*uv.y,1.0);
    o.rgb = (1.0-cos(o.rgb-0.5))*5.0;
	
	COLOR = vec4(o.r,o.g,o.b,a);
	//COLOR = o;
}"

[sub_resource type="ShaderMaterial" id=6]
shader = SubResource( 5 )
shader_param/PI = 3.14

[sub_resource type="ShaderMaterial" id=7]
render_priority = 10
shader = ExtResource( 11 )
shader_param/color = Vector3( 0.35, 0.48, 0.95 )
shader_param/OCTAVES = 4

[sub_resource type="Shader" id=8]
code = "shader_type canvas_item;
//https://www.shadertoy.com/view/XsVSzW

uniform vec2 iMouse;
uniform vec2 resolution;

void fragment( )
{
	float time = TIME;
	vec2 uv = ( FRAGCOORD.xy / (1.0/SCREEN_PIXEL_SIZE).xy )*4.0;

	vec2 uv0=uv;
	float i0=1.5;
	float i1=0.95;
	float i2=1.5;
	vec2 i4=vec2(0.0,0.0);
	
	for(int s=0;s<10;s++)
	{
		vec2 r;
		r=vec2(cos(uv.y*i0-i4.y+time/i1),sin(uv.x*i0+i4.x+time/i1))/i2;
		r+=vec2(-r.y,r.x)*0.2;
		uv.xy+=r;
        
		i0*=1.93;
		i1*=1.25;
		i2*=1.7;
		i4+=r.xy*1.0+0.5*time*i1;
	}
	
	float r=sin(uv.x-time)*0.5+0.5;
	float g=cos(uv.y+time)*0.5+0.5;
	float b=sin((sqrt(uv.x*uv.x+uv.y*uv.y)+time))*0.5+0.8;
	
	//tan(uv.x+uv.y+time)*0.5+0.5; //
	vec3 c=vec3(r,g,b);
	COLOR = vec4(c,1.0);
}"

[sub_resource type="ShaderMaterial" id=9]
shader = SubResource( 8 )
shader_param/iMouse = null
shader_param/resolution = null

[sub_resource type="Shader" id=10]
code = "shader_type canvas_item;

//https://www.shadertoy.com/view/4djXzz

/*--------------------------------------------------------------------------------------
License CC0 - http://creativecommons.org/publicdomain/zero/1.0/
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.
----------------------------------------------------------------------------------------
^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.
-Otavio Good
*/


//Color Palette

uniform vec2 iMouse;

vec3 palette( in float t)
{
    vec3 a = vec3(0.5,0.5,1.0);
    vec3 b = vec3(1.0,0.5,0.5);
    vec3 c = vec3(1.0,1.0,0.0);
    vec3 d = vec3(0.5,0.20,0.25);
    float tau = 6.28318;
    
    return a +b*cos(tau*(c*t+d));
}

// various noise functions
float Hash2d(vec2 uv)
{
    float f = uv.x + uv.y * 47.0;
    return fract(cos(f*3.333)*100003.9);
}
float Hash3d(vec3 uv)
{
    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;
    return fract(cos(f*3.333)*100003.9);
}
float mixP(float f0, float f1, float a)
{
    return mix(f0, f1, a*a*(3.0-2.0*a));
}
vec3 zeroOne(){
	// might be 0.1
	return vec3(0.0, 1.0,0.0);
}
	
float noise2d(vec2 uv)
{
    vec2 fr = fract(uv.xy);
    vec2 fl = floor(uv.xy);
    float h00 = Hash2d(fl);
    float h10 = Hash2d(fl + zeroOne().yx);
    float h01 = Hash2d(fl + zeroOne().xy);
    float h11 = Hash2d(fl + zeroOne().yy);
    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);
}
/*
float noise2dT(vec2 uv, sampler2D iChannel0)
{
    vec2 fr = fract(uv);
    vec2 smoothv = fr*fr*(3.0-2.0*fr);
    vec2 fl = floor(uv);
    uv = smoothv + fl;
    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).y;	// use constant here instead?
}
*/
float noise(vec3 uv)
{
    vec3 fr = fract(uv.xyz);
    vec3 fl = floor(uv.xyz);
    float h000 = Hash3d(fl);
    float h100 = Hash3d(fl + zeroOne().yxx);
    float h010 = Hash3d(fl + zeroOne().xyx);
    float h110 = Hash3d(fl + zeroOne().yyx);
    float h001 = Hash3d(fl + zeroOne().xxy);
    float h101 = Hash3d(fl + zeroOne().yxy);
    float h011 = Hash3d(fl + zeroOne().xyy);
    float h111 = Hash3d(fl + zeroOne().yyy);
    return mixP(
        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),
        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)
        , fr.z);
}

uniform float PI=3.14159265;

vec3 saturate(vec3 a)
{
	return clamp(a, 0.0, 1.0);
}
vec2 saturate(vec2 a)
{
	return clamp(a, 0.0, 1.0);
}
float saturate(float a)
{
	return clamp(a, 0.0, 1.0);
}

float Density(vec3 p)
{
    //float ws = 0.06125*0.125;
    //vec3 warp = vec3(noise(p*ws), noise(p*ws + 111.11), noise(p*ws + 7111.11));
    float final = noise(p*0.06125);// + sin(iTime)*0.5-1.95 + warp.x*4.0;
    float other = noise(p*0.06125 + 1234.567);
    other -= 0.5;
    final -= 0.5;
    final = 0.1/(abs(final*final*other));
    final += 0.5;
    return final*0.0001;
}

void fragment()
{
	// ---------------- First, set up the camera rays for ray marching ----------------
	vec2 iResolution = (1.0/SCREEN_PIXEL_SIZE);
	float iTime = TIME;
	vec2 uv = FRAGCOORD.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;

	// Camera up vector.
	vec3 camUp=vec3(0,1,0); // vuv

	// Camera lookat.
	vec3 camLookat=vec3(0,0.0,0);	// vrp
	
    //mouse sensitivity scale 0-1
    float mSensitivity = 0.001;
	float mx=mSensitivity*iMouse.x/iResolution.x*PI*2.0 + iTime * 0.01;
	float my=mSensitivity*-iMouse.y/iResolution.y*10.0 + sin(iTime * 0.03)*0.2+0.2;//*PI/2.01;
	vec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); 	// prp

	// Camera setup.
	vec3 camVec=normalize(camLookat - camPos);//vpn
	vec3 sideNorm=normalize(cross(camUp, camVec));	// u
	vec3 upNorm=cross(camVec, sideNorm);//v
	vec3 worldFacing=(camPos + camVec);//vcv
	vec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord
	vec3 relVec = normalize(worldPix - camPos);//scp

	// --------------------------------------------------------------------------------
	float t = 0.0;
	float inc = 0.02;
	float maxDepth = 70.0;
	vec3 pos = vec3(0,0,0);
    float density = 0.0;
	// ray marching time
    for (int i = 0; i < 37; i++)	// This is the count of how many times the ray actually marches.
    {
        if ((t > maxDepth)) break;
        pos = camPos + relVec * t;
        float temp = Density(pos);
        //temp *= saturate(t-1.0);

        inc = 1.9 + temp*0.05;	// add temp because this makes it look extra crazy!
        density += temp * inc;
        t += inc;
    }

	// --------------------------------------------------------------------------------
	// Now that we have done our ray marching, let's put some color on this.
    vec3 color = palette(iTime*mSensitivity);
	vec3 finalColor = color*mSensitivity* density*0.5;
    
    //vec3(0.01,0.1,1.0)

	// output the final color with sqrt for \"gamma correction\"
	COLOR = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);
    //fragColor = vec4(finalColor,1.0);
    
}
"

[sub_resource type="ShaderMaterial" id=11]
shader = SubResource( 10 )
shader_param/iMouse = null
shader_param/PI = 3.14159

[sub_resource type="Shader" id=12]
code = "shader_type canvas_item;

uniform float pi =  3.14159;

//#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a)) // col1a col1b col2a col2b

mat2 rot(float a) {
    return mat2(vec2(cos(a), -sin(a)), vec2(sin(a), cos(a)));
}

// source: http://iquilezles.org/www/articles/palettes/palettes.htm
vec3 palette( in float t)
{
    vec3 a = vec3(0.5,0.5,1.0);
    vec3 b = vec3(1.0,0.5,0.5);
    vec3 c = vec3(1.0,1.0,0.0);
    vec3 d = vec3(0.5,0.20,0.25);
    float tau = 6.28318;
    
    return a +b*cos(tau*(c*t+d));
}

void fragment()
{
	vec2 uv0 = FRAGCOORD.xy /(1.0/SCREEN_PIXEL_SIZE).xy + vec2(sin(TIME), cos(TIME)) * .01;
    vec2 uv = 2. * uv0 - 1.;
    uv.x *= (1.0/SCREEN_PIXEL_SIZE).x / (1.0/SCREEN_PIXEL_SIZE).y;
    uv = abs(uv * rot(TIME * 4.));
    
   	float d = max(uv.x, uv.y);
    
    vec3 color = palette(TIME);
    
    float uvMax = 1.;
    float innerEdge = mod(TIME / 3., uvMax);
    float outerEdge = .075 + innerEdge;
    float repeat = .75;
    d = mod(d, repeat) * (uvMax / repeat);
    d += floor(outerEdge/uvMax) * uvMax * step(d, mod(outerEdge, uvMax));
    d = step(innerEdge, d) * step(d, outerEdge);
    
    COLOR.rgb = .9 * texture(SCREEN_TEXTURE, uv0).rgb + d * color;
}"

[sub_resource type="ShaderMaterial" id=13]
shader = SubResource( 12 )
shader_param/pi = 3.14159

[sub_resource type="Shader" id=14]
code = "shader_type canvas_item;
void fragment()
{
	vec2 uv = FRAGCOORD.xy / (1.0/SCREEN_PIXEL_SIZE).xy;
    //vec3 rgb = textureLod(SCREEN_TEXTURE, uv).xyz;
    //COLOR = vec4(rgb*0.2, 1.);
	vec3 c = textureLod(SCREEN_TEXTURE, SCREEN_UV,1.0).rgb;
    COLOR = vec4(c, 1.);
}"

[sub_resource type="ShaderMaterial" id=15]
shader = SubResource( 14 )

[sub_resource type="Shader" id=16]
code = "shader_type canvas_item;

uniform float pi =  3.14159;

//#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a)) // col1a col1b col2a col2b

mat2 rot(float a) {
    return mat2(vec2(cos(a), -sin(a)), vec2(sin(a), cos(a)));
}

// source: http://iquilezles.org/www/articles/palettes/palettes.htm
vec3 palette( in float t)
{
    vec3 a = vec3(0.5,0.5,1.0);
    vec3 b = vec3(1.0,0.5,0.5);
    vec3 c = vec3(1.0,1.0,0.0);
    vec3 d = vec3(0.5,0.20,0.25);
    float tau = 6.28318;
    
    return a +b*cos(tau*(c*t+d));
}

void fragment()
{
	vec2 uv0 = FRAGCOORD.xy /(1.0/SCREEN_PIXEL_SIZE).xy + vec2(sin(TIME), cos(TIME)) * .01;
    vec2 uv = 2. * uv0 - 1.;
    uv.x *= (1.0/SCREEN_PIXEL_SIZE).x / (1.0/SCREEN_PIXEL_SIZE).y;
    uv = abs(uv * rot(TIME * 4.));
    
   	float d = max(uv.x, uv.y);
    
    vec3 color = palette(TIME);
    
    float uvMax = 1.;
    float innerEdge = mod(TIME / 3., uvMax);
    float outerEdge = .075 + innerEdge;
    float repeat = .75;
    d = mod(d, repeat) * (uvMax / repeat);
    d += floor(outerEdge/uvMax) * uvMax * step(d, mod(outerEdge, uvMax));
    d = step(innerEdge, d) * step(d, outerEdge);
    
    COLOR.rgb = .9 * texture(TEXTURE, uv0).rgb + d * color;
}"

[sub_resource type="ShaderMaterial" id=17]
shader = SubResource( 16 )
shader_param/pi = 3.14159

[sub_resource type="Shader" id=18]
code = "shader_type canvas_item;

void fragment()
{
	//vec2 uv = FRAGCOORD.xy / (1.0/SCREEN_PIXEL_SIZE).xy;
    //vec3 rgb = textureLod(SCREEN_TEXTURE, uv).xyz;
    //COLOR = vec4(rgb*0.2, 1.);
	vec3 c = textureLod(SCREEN_TEXTURE, SCREEN_UV,0.0).xyz;
    //COLOR = vec4(c, 0.5);
    c.x = mod(c.x/35.0, 1.0);
	if (c.x > 0.0){
		COLOR = vec4(c, 0.0);
	}else{
    	COLOR = vec4(c, 1.);
	}
	
}"

[sub_resource type="ShaderMaterial" id=19]
shader = SubResource( 18 )

[sub_resource type="Shader" id=20]
code = "shader_type canvas_item;

uniform float M_PI = 3.1415926535897932384626433832795;
uniform vec2 iMouse;
float M_TWO_PI (){return 2.0 * M_PI;}

float rand(vec2 n) {
    return fract(sin(dot(n, vec2(12.9898,12.1414))) * 83758.5453);
}

float noise(vec2 n) {
    vec2 d = vec2(0.0, 1.0);
    vec2 b = floor(n);
    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}

vec3 ramp(float t) {
	return t <= .5 ? vec3( 1. - t * 1.4, .2, 1.05 ) / t : vec3( .3 * (1. - t) * 2., .2, 1.05 ) / t;
}
vec2 polarMap(vec2 uv, float shift, float inner) {

    uv = vec2(0.5) - uv;
    
    
    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;
    float py = (sqrt(uv.x * uv.x + uv.y * uv.y) * (1.0 + inner * 2.0) - inner) * 2.0;
    
    return vec2(px, py);
}
float fire(vec2 n) {
    return noise(n) + noise(n * 2.1) * .6 + noise(n * 5.4) * .42;
}

float shade(vec2 uv, float t) {
    uv.x += uv.y < .5 ? 23.0 + t * .035 : -11.0 + t * .03;    
    uv.y = abs(uv.y - .5);
    uv.x *= 35.0;
    
    float q = fire(uv - t * .013) / 2.0;
    vec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));
    
    return pow((r.y + r.y) * max(.0, uv.y) + .1, 4.0);
}

vec3 color(float grad, vec2 iResolution) {
	//float m2 = iMouse.z < 0.0001 ? 1.15 : iMouse.y * 3.0 / iResolution.y;
    float m2 = iMouse.y * 3.0 / iResolution.y;
    grad =sqrt( grad);
    vec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .1) + 2.61, vec3(2.0))));
    vec3 color2 = color;
    color = ramp(grad);
    color /= (m2 + max(vec3(0), color));
    
    return color;

}
varying float CAMERA;

void vertex() {
  CAMERA = 0.1;
}

void fragment() {
	vec2 iResolution = (1.0/SCREEN_PIXEL_SIZE);
	//float m1 = iMouse.z < 0.0001 ? 3.6 : iMouse.x * 5.0 / iResolution.x;
    float m1 = iMouse.x * 5.0 / iResolution.x;
	//float m1 = iMouse.x < 0.0001 ? 3.6 : iMouse.x * 5.0 / iResolution.x;
    
    float t = TIME;
    vec2 uv = FRAGCOORD.xy / iResolution.yy;
    float ff = 1.0 - uv.y;
    uv.x -= (iResolution.x / iResolution.y - 1.0) / 2.0;
    vec2 uv2 = uv;
    uv2.y = 1.0 - uv2.y;
   	uv = polarMap(uv, 1.3, m1);
   	uv2 = polarMap(uv2, 1.9, m1);

    vec3 c1 = color(shade(uv, t),iResolution) * ff;
    vec3 c2 = color(shade(uv2, t),iResolution) * (1.0 - ff);
    
    COLOR = vec4(c1 + c2, 1.0);
}"

[sub_resource type="ShaderMaterial" id=21]
render_priority = 10
shader = SubResource( 20 )
shader_param/M_PI = 3.14159
shader_param/iMouse = null

[sub_resource type="Shader" id=22]
code = "shader_type canvas_item;
// Plasma Globe by nimitz (twitter: @stormoid)
// https://www.shadertoy.com/view/XsjXRm
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Contact the author for other licensing options

//looks best with around 25 rays
uniform float NUM_RAYS = 25.; //25.
uniform float VOLUMETRIC_STEPS = 19.;//19
uniform float MAX_ITER = 35.; //35
uniform float FAR = 6.; //6.0
uniform vec2 iMouse;
mat3 m3(){
	//return mat3( vec3(1.00,  0.80,  0.60), vec3(-0.80,  0.36, -0.48), vec3(-0.60, -0.48,  0.64 ));
	return mat3(vec3(0.1),vec3(0.1),vec3(0.1));
}



mat2 mm2(in float a)
{
	float c = cos(a), s = sin(a);
	return mat2(vec2(c,-s),vec2(s,c));
	
	}
float noise( in float x, in sampler2D iChannel0 )
{
	return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;
}

float hash( float n ){return fract(sin(n)*43758.5453);}

float noise(in vec3 p, in sampler2D iChannel0)
{
	vec3 ip = floor(p);
    vec3 fp = fract(p);
	fp = fp*fp*(3.0-2.0*fp);
	
	vec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;
	vec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;
	return mix(rg.x, rg.y, fp.z);
}
	//varying mat3 m3;
	
//mat3 m3 = mat3( (0.00,  0.80,  0.60), (-0.80,  0.36, -0.48), (-0.60, -0.48,  0.64 ));

//See: https://www.shadertoy.com/view/XdfXRj
float flow(in vec3 p, in float t, in sampler2D iChannel0)
{
	float z=2.;
	float rz = 0.;
	vec3 bp = p;
	for (float i= 1.;i < 5.;i++ )
	{
		p += t*.1;
		rz+= (sin(noise(p+t*0.8,iChannel0)*6.)*0.5+0.5) /z;
		p = mix(bp,p,0.6);
		z *= 2.;
		p *= 2.01;
        p*= m3();
	}
	return rz;	
}

//could be improved
float sins(in float x, in float t)
{
 	float rz = 0.;
    float z = 2.;
    for (float i= 0.;i < 3.;i++ )
	{
        rz += abs(fract(x*1.4)-0.5)/z;
        x *= 1.3;
        z *= 1.15;
        x -= t*.65*z;
    }
    return rz;
}

float segm( vec3 p, vec3 a, vec3 b)
{
    vec3 pa = p - a;
	vec3 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );	
	return length( pa - ba*h )*.5;
}

vec3 path(in float i, in float d, in float t)
{
    vec3 en = vec3(0.,0.,1.);
    float sns2 = sins(d+i*0.5,t)*0.22;
    float sns = sins(d+i*.6,t)*0.21;
    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);
    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);
    return en;
}

vec2 map(vec3 p, float i, in float t)
{
	float lp = length(p);
    vec3 bg = vec3(0.);   
    vec3 en = path(i,lp,t);
    
    float ins = smoothstep(0.11,.46,lp);
    float outs = .15+smoothstep(.0,.15,abs(lp-1.));
    p *= ins*outs;
    float id = ins*outs;
    
    float rz = segm(p, bg, en)-0.011;
    return vec2(rz,id);
}

float march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j, in float t)
{
	float precis = 0.001;
    float h=0.5;
    float d = startf;
    for( float i=0.0; i<MAX_ITER; i++ )
    {
        if( abs(h)<precis||d>maxd ) break;
        d += h*1.2;
	    float res = map(ro+rd*d, j,t).x;
        h = res;
    }
	return d;
}

//volumetric marching
vec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig, in float t,in sampler2D iChannel0)
{   
    vec3 p = ro;
    vec2 r = vec2(0.);
    vec3 sum = vec3(0);
    float w = 0.;
    for( float i=0.0; i<VOLUMETRIC_STEPS; i++ )
    {
        r = map(p,j,t);
        p += rd*.03;
        float lp = length(p);
        
        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;
        col.rgb *= smoothstep(.0,.015,-r.x);
        col *= smoothstep(0.04,.2,abs(lp-1.1));
        col *= smoothstep(0.1,.34,lp);
        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+t*5.,iChannel0)*1.1) / (log(distance(p,orig)-2.)+.75);
    }
    return sum;
}

//returns both collision dists of unit sphere
vec2 iSphere2(in vec3 ro, in vec3 rd)
{
    vec3 oc = ro;
    float b = dot(oc, rd);
    float c = dot(oc,oc) - 1.;
    float h = b*b - c;
    if(h <0.0) return vec2(-1.);
    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));
}

void fragment()
{	

	//m3 = mat3( vec3(1.00,  0.80,  0.60), vec3(-0.80,  0.36, -0.48), vec3(-0.60, -0.48,  0.64 ));
	float time = TIME*1.1;
	
	vec2 p = FRAGCOORD.xy/(1.0/SCREEN_PIXEL_SIZE).xy-0.5;
	p.x*=(1.0/SCREEN_PIXEL_SIZE).x/(1.0/SCREEN_PIXEL_SIZE).y;
//MOUSE
	vec2 um = vec2(0.0,0.0); //iMouse.xy / (1.0/SCREEN_PIXEL_SIZE).xy-.5;
    
	//camera
	vec3 ro = vec3(0.,0.,5.);
    vec3 rd = normalize(vec3(p*.7,-1.5));
    mat2 mx = mm2(time*.4+um.x*6.);
    mat2 my = mm2(time*0.3+um.y*6.); 
    ro.xz *= mx;rd.xz *= mx;
    ro.xy *= my;rd.xy *= my;
    
    vec3 bro = ro;
    vec3 brd = rd;
	
    vec3 col = vec3(0.0125,0.,0.025);

    for (float j = 1.;j<NUM_RAYS+1.;j++)
    {
        ro = bro;
        rd = brd;
        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);
        ro.xy *= mm;rd.xy *= mm;
        ro.xz *= mm;rd.xz *= mm;
        float rz = march(ro,rd,2.5,FAR,j,time);
		if ( rz >= FAR)continue;
    	vec3 pos = ro+rz*rd;
    	col = max(col,vmarch(pos,rd,j, bro,time,TEXTURE));
    }
 
    ro = bro;
    rd = brd;
    vec2 sph = iSphere2(ro,rd);
    
    if (sph.x > 0.5)
    {
        vec3 pos = ro+rd*sph.x;
        vec3 pos2 = ro+rd*sph.y;
        vec3 rf = reflect( rd, pos );
        vec3 rf2 = reflect( rd, pos2 );
        float nz = (-log(abs(flow(rf*1.2,time,TEXTURE)-.01)));
        float nz2 = (-log(abs(flow(rf2*1.2,-time,TEXTURE)-.01)));
        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;
    }

	COLOR = vec4(col*0.3, 1.0);
}"

[sub_resource type="ShaderMaterial" id=23]
shader = SubResource( 22 )
shader_param/NUM_RAYS = 25.0
shader_param/VOLUMETRIC_STEPS = 19.0
shader_param/MAX_ITER = 35.0
shader_param/FAR = 6.0
shader_param/iMouse = null

[sub_resource type="Shader" id=24]
code = "//////////////////////////////////////////////////////////////////////////////////
// Spiral of Spirals - Copyright 2018 Frank Force
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
//////////////////////////////////////////////////////////////////////////////////
//https://www.shadertoy.com/view/XsdBRj

shader_type canvas_item;

uniform float pi = 3.14159265359;
uniform vec2 iMouse;
uniform vec2 iResolution;

vec3 hsv2rgb(vec3 c)
{
    float s = c.y * c.z;
    float s_n = c.z - s * .5;
    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));
}

vec3 GetSpiralColor(float a, float i, float t)
{
    
    // fixed size
    //t *= 1.0 - 0.9*mousePos.w;
    //a *= 1.0 + mousePos.w*(floor(i)+p);
    
    a += 2.0*pi*floor(i);
   
    // apply color
    float h = a;
    h *= 1.003*t;
    //h *= 0.1*(floor(i)+p);
    h = 0.5*(sin(h) + 1.0);
    h = pow(h, 3.0);
    h += 1.222*t + 0.4;
    
    float s = a;
    s *= 1.01*t;
    s = 0.5*(sin(s) + 1.0);
    s = pow(s, 2.0);
    
    float v = a;
    v *= t;
    v = sin(v);
    v = 0.5*(v + 1.0);
    v = pow(v, 3.0);
    //v *= pow(sin(fract(i)*pi), 0.4);
    
    return vec3(h, s, v);
}       
        
void fragment()
{
	vec2 uv = FRAGCOORD.xy;
	//(1.0/SCREEN_PIXEL_SIZE)
    uv -= (1.0/SCREEN_PIXEL_SIZE).xy / 2.0;
    uv /= (1.0/SCREEN_PIXEL_SIZE).x;
   
    vec2 mousePos = (iMouse.xy / (1.0/SCREEN_PIXEL_SIZE).xy);
	//vec2 mousePos = (SCREEN_PIXEL_SIZE/200.0).xy; //(vec2(TIME/50.0,TIME/50.0).xy / (1.0/SCREEN_PIXEL_SIZE).xy);
 	uv *= 40.0;
    // if (mousePos.y > 0.0)
    //	uv *= 4.0 * (mousePos.y+mousePos.x)*0.5;
    uv *= (tan(TIME)*sin(TIME));
    float a = atan(uv.y, uv.x);
    float d = length(uv);
    
    // apply slight pow so center is smaller
    d = pow(10.0*d, 0.7);
    
    // make spiral
    float i = d;
    i -= a/(2.0*pi) + 0.5;
    
    // change over time
	// + 40.*(mousePos.x)
    float t = .05*(TIME);
    
    vec3 c1 = hsv2rgb(GetSpiralColor(a, i, t));
    vec3 c2 = hsv2rgb(GetSpiralColor(a, i+1.0, t));
    
    float p = fract(i);
    vec3 c3 = mix(c1, c2, p);
    
	COLOR = vec4(c3, 1.0);
}"

[sub_resource type="ShaderMaterial" id=25]
shader = SubResource( 24 )
shader_param/pi = 3.14159
shader_param/iMouse = null
shader_param/iResolution = null

[sub_resource type="Shader" id=26]
code = "shader_type canvas_item;
// Original by bonniem, remixed by ADOB then ChazMeister
//https://www.shadertoy.com/view/XtjXDW



float squared(float value) { return value * value; }

float getAmp(float frequency,sampler2D iChannel0) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }

float getWeight(float f,sampler2D iChannel0) {
    return (+ getAmp(f-2.0,iChannel0) + getAmp(f-1.0,iChannel0) + getAmp(f+2.0,iChannel0) + getAmp(f+1.0,iChannel0) + getAmp(f,iChannel0)) / 5.0; }

void fragment()
{    
	vec2 uvTrue = FRAGCOORD.xy / (1.0/SCREEN_PIXEL_SIZE).xy;
    vec2 uv = -1.0 + 2.0 * uvTrue;
    
	float lineIntensity;
    float glowWidth;
    vec3 color = vec3(0.0);
    float i = 0.0;
	for(i = 0.0; i < 7.0; i++) {
        
		uv.y += (0.2 * sin(uv.x + i/7.0 - TIME * 0.6));
        float Y = uv.y + getWeight(squared(i) * 20.0,TEXTURE) *
            (texture(TEXTURE, vec2(uvTrue.x, 1)).x - 0.5);
        lineIntensity = 0.15 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + TIME,2.0) - 1.0)); //0.4
		glowWidth = abs(lineIntensity / ((500.0+(sin(TIME)*350.0)) * Y)); //150.0  
		color += vec3(glowWidth * (2.0 + sin(TIME * 0.13)),
                      glowWidth * (2.0 - sin(TIME * 0.23)),
                      glowWidth * (2.0 - cos(TIME * 0.19)));
	}	
	
	COLOR = vec4((color / 2.0) * (getWeight(squared(i) * 20.0,TEXTURE) * 2.5), 1.0);
}"

[sub_resource type="ShaderMaterial" id=27]
shader = SubResource( 26 )

[sub_resource type="ShaderMaterial" id=28]

[sub_resource type="Shader" id=29]
code = "shader_type canvas_item;

uniform float PI = 3.14;
void fragment()
{
    float scale = 5.0;
    float i = TIME*.5;
    vec4 o = vec4(0.0);
	vec2 uv = FRAGCOORD.xy / (1.0/SCREEN_PIXEL_SIZE).xy*scale;
    uv-= scale*0.5;
    
    mat2 m = mat2(vec2(cos(uv.x-i),sin(sin(uv.x)+i)),vec2(cos(uv.y+i),cos(uv.y-i*.5)));
    uv = uv*m;
    
    float dist = length(uv);
    float a = atan(uv.y,uv.x);
    o.r = mod(dist,1.0);
    o.g = mod(a,0.5)*2.0;
    o.b = mod(uv.x*uv.y,1.0);
    o.rgb = (1.0-cos(o.rgb-0.5))*5.0;
	
	COLOR = o;
}"

[sub_resource type="ShaderMaterial" id=30]
shader = SubResource( 29 )
shader_param/PI = 3.14

[sub_resource type="Shader" id=31]
code = "shader_type canvas_item;
// Plasma Globe by nimitz (twitter: @stormoid)
// https://www.shadertoy.com/view/XsjXRm
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Contact the author for other licensing options

//looks best with around 25 rays
uniform float NUM_RAYS = 25.;
uniform float VOLUMETRIC_STEPS = 19;
uniform float MAX_ITER = 35;
uniform float FAR = 6.;




mat2 mm2(in float a)
{
	float c = cos(a), s = sin(a);
	return mat2(vec2(c,-s),vec2(s,c));
	
	}
float noise( in float x, in sampler2D iChannel0 )
{
	return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;
}

float hash( float n ){return fract(sin(n)*43758.5453);}

float noise(in vec3 p, in sampler2D iChannel0)
{
	vec3 ip = floor(p);
    vec3 fp = fract(p);
	fp = fp*fp*(3.0-2.0*fp);
	
	vec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;
	vec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;
	return mix(rg.x, rg.y, fp.z);
}
	//varying mat3 m3;
	
//mat3 m3 = mat3( (0.00,  0.80,  0.60), (-0.80,  0.36, -0.48), (-0.60, -0.48,  0.64 ));

//See: https://www.shadertoy.com/view/XdfXRj
float flow(in vec3 p, in float t, in sampler2D iChannel0, in mat3 m3)
{
	float z=2.;
	float rz = 0.;
	vec3 bp = p;
	for (float i= 1.;i < 5.;i++ )
	{
		p += t*.1;
		rz+= (sin(noise(p+t*0.8,iChannel0)*6.)*0.5+0.5) /z;
		p = mix(bp,p,0.6);
		z *= 2.;
		p *= 2.01;
        p*= m3;
	}
	return rz;	
}

//could be improved
float sins(in float x, in float t)
{
 	float rz = 0.;
    float z = 2.;
    for (float i= 0.;i < 3.;i++ )
	{
        rz += abs(fract(x*1.4)-0.5)/z;
        x *= 1.3;
        z *= 1.15;
        x -= t*.65*z;
    }
    return rz;
}

float segm( vec3 p, vec3 a, vec3 b)
{
    vec3 pa = p - a;
	vec3 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );	
	return length( pa - ba*h )*.5;
}

vec3 path(in float i, in float d, in float t)
{
    vec3 en = vec3(0.,0.,1.);
    float sns2 = sins(d+i*0.5,t)*0.22;
    float sns = sins(d+i*.6,t)*0.21;
    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);
    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);
    return en;
}

vec2 map(vec3 p, float i, in float t)
{
	float lp = length(p);
    vec3 bg = vec3(0.);   
    vec3 en = path(i,lp,t);
    
    float ins = smoothstep(0.11,.46,lp);
    float outs = .15+smoothstep(.0,.15,abs(lp-1.));
    p *= ins*outs;
    float id = ins*outs;
    
    float rz = segm(p, bg, en)-0.011;
    return vec2(rz,id);
}

float march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j, in float t)
{
	float precis = 0.001;
    float h=0.5;
    float d = startf;
    for( float i=0.0; i<MAX_ITER; i++ )
    {
        if( abs(h)<precis||d>maxd ) break;
        d += h*1.2;
	    float res = map(ro+rd*d, j,t).x;
        h = res;
    }
	return d;
}

//volumetric marching
vec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig, in float t,in sampler2D iChannel0)
{   
    vec3 p = ro;
    vec2 r = vec2(0.);
    vec3 sum = vec3(0);
    float w = 0.;
    for( float i=0.0; i<VOLUMETRIC_STEPS; i++ )
    {
        r = map(p,j,t);
        p += rd*.03;
        float lp = length(p);
        
        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;
        col.rgb *= smoothstep(.0,.015,-r.x);
        col *= smoothstep(0.04,.2,abs(lp-1.1));
        col *= smoothstep(0.1,.34,lp);
        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+t*5.,iChannel0)*1.1) / (log(distance(p,orig)-2.)+.75);
    }
    return sum;
}

//returns both collision dists of unit sphere
vec2 iSphere2(in vec3 ro, in vec3 rd)
{
    vec3 oc = ro;
    float b = dot(oc, rd);
    float c = dot(oc,oc) - 1.;
    float h = b*b - c;
    if(h <0.0) return vec2(-1.);
    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));
}

void fragment()
{	
	mat3 m3 = mat3( vec3(1.00,  0.80,  0.60), vec3(-0.80,  0.36, -0.48), vec3(-0.60, -0.48,  0.64 ));
	float time = TIME*1.1;
	
	vec2 p = FRAGCOORD.xy/(1.0/SCREEN_PIXEL_SIZE).xy-0.5;
	p.x*=(1.0/SCREEN_PIXEL_SIZE).x/(1.0/SCREEN_PIXEL_SIZE).y;
	//imouse here
	vec2 um = vec2(1,1); // / (1.0/SCREEN_PIXEL_SIZE).xy-.5;
    
	//camera
	vec3 ro = vec3(0.,0.,5.);
    vec3 rd = normalize(vec3(p*.7,-1.5));
    mat2 mx = mm2(time*.4+um.x*6.);
    mat2 my = mm2(time*0.3+um.y*6.); 
    ro.xz *= mx;rd.xz *= mx;
    ro.xy *= my;rd.xy *= my;
    
    vec3 bro = ro;
    vec3 brd = rd;
	
    vec3 col = vec3(0.0125,0.,0.025);

    for (float j = 1.;j<NUM_RAYS+1.;j++)
    {
        ro = bro;
        rd = brd;
        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);
        ro.xy *= mm;rd.xy *= mm;
        ro.xz *= mm;rd.xz *= mm;
        float rz = march(ro,rd,2.5,FAR,j,TIME);
		if ( rz >= FAR)continue;
    	vec3 pos = ro+rz*rd;
    	col = max(col,vmarch(pos,rd,j, bro,TIME,TEXTURE));
    }
    
    ro = bro;
    rd = brd;
    vec2 sph = iSphere2(ro,rd);
    
    if (sph.x > 0.)
    {
        vec3 pos = ro+rd*sph.x;
        vec3 pos2 = ro+rd*sph.y;
        vec3 rf = reflect( rd, pos );
        vec3 rf2 = reflect( rd, pos2 );
        float nz = (-log(abs(flow(rf*1.2,time,TEXTURE,m3)-.01)));
        float nz2 = (-log(abs(flow(rf2*1.2,-time,TEXTURE,m3)-.01)));
        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;
    }
    
	COLOR = vec4(col*1.3, 1.0);
}"

[sub_resource type="ShaderMaterial" id=32]
shader = SubResource( 31 )
shader_param/NUM_RAYS = 25.0
shader_param/VOLUMETRIC_STEPS = 19.0
shader_param/MAX_ITER = 35.0
shader_param/FAR = 6.0

[sub_resource type="Shader" id=33]
code = "shader_type canvas_item;

void fragment(){
	



	
	vec2 uv = FRAGCOORD.xy/(1.0/SCREEN_PIXEL_SIZE).xy;
    float t = TIME-2.8;
    float s = sin(t/16.), c = cos(t/16.);
    vec2 muv = FRAGCOORD.xy/(1.0/SCREEN_PIXEL_SIZE).xy-.5;
    muv += .01*sin(muv.yx*vec2(10.5,8.3)+t/8.);

    muv *= mat2(vec2(s,c),vec2(c,-s));
    float sc = 2.5+.5*sin(TIME*.4);
    muv *= smoothstep(0.,12.,t)*sc;
    muv = abs(muv);
    muv = fract(abs(muv-1.));
    float n = sin(t/2.)*.2+.8;
    vec4 last = texture(TEXTURE,muv*n);
    vec4 new = .1/length(muv-vec2(.4+.2*s,.5+.05*c))*vec4(uv,1,1);
    COLOR = (last*min(.75,t/15.)-.1)+new;
	
	}"

[sub_resource type="ShaderMaterial" id=34]
shader = SubResource( 33 )

[sub_resource type="Shader" id=35]
code = "shader_type canvas_item;
//https://www.shadertoy.com/view/4dSBRd
//uniform float sin01(x) = (.5+.5*sin(x));

void fragment()
{

    if(TIME < 132.)
    {
        vec2 uv = FRAGCOORD.xy / (1.0 / SCREEN_PIXEL_SIZE).xy;   
        vec2 ouv = uv;

        float v = smoothstep(2.,9.,TIME)*.44;
		//(.5+.5*sin(TIME))
		//float cs = TIME < 7. ? 0. : .6+.4*sin(TIME);
        float cs = TIME < 7. ? 0. : .6+.4*sin(TIME);

        if(abs(uv.y-.5) < v)
        {
            uv += .005*cs*cos(2.*TIME+TIME*vec2(2,3));

            uv *= .9;
            uv +=.03;

            vec4 blur = textureLod(TEXTURE,uv,0.5);

            blur = (blur-.6)*6.;
            blur = max(blur,vec4(0));
            float bloom = length(blur.xyz);

            bloom *= bloom*bloom/2.;

            vec4 tex = texture(TEXTURE,uv);

            float vn = 1.-1.6*length(ouv-0.5);

            COLOR = tex+.4*tex*bloom;
            COLOR = pow(COLOR,vec4(.8));
            COLOR *= vn;
        }
    }
  else
       discard;
}"

[sub_resource type="ShaderMaterial" id=36]
shader = SubResource( 35 )

[sub_resource type="ShaderMaterial" id=37]
shader = ExtResource( 17 )
shader_param/PI = 3.14

[node name="Background" type="Node2D"]
script = ExtResource( 1 )

[node name="cyberpunk-city-night-scenery-sci-fi-uhdpapercom-4K-94" type="TextureRect" parent="."]
visible = false
margin_left = 1.0
margin_top = 17.0
margin_right = 1286.0
margin_bottom = 729.0
texture = ExtResource( 2 )
expand = true

[node name="991947180" type="TextureRect" parent="."]
visible = false
margin_left = -5.0
margin_top = 14.0
margin_right = 1284.0
margin_bottom = 720.0
texture = ExtResource( 3 )
expand = true

[node name="cyberpunk_nebula" type="TextureRect" parent="."]
visible = false
margin_left = 3.51617
margin_top = 3.0
margin_right = 1280.52
margin_bottom = 722.0
texture = ExtResource( 4 )
expand = true

[node name="998938790" type="TextureRect" parent="."]
visible = false
margin_left = 1.0
margin_right = 1287.0
margin_bottom = 732.0
texture = ExtResource( 5 )
expand = true

[node name="cyberclouds" type="TextureRect" parent="."]
visible = false
margin_left = 1.0
margin_top = -3.0
margin_right = 1293.0
margin_bottom = 733.0
texture = ExtResource( 6 )
expand = true

[node name="cyberclouds3" type="TextureRect" parent="."]
visible = false
material = SubResource( 2 )
margin_left = 1.0
margin_top = -3.0
margin_right = 1293.0
margin_bottom = 733.0
texture = ExtResource( 6 )
expand = true

[node name="cyberclouds2" type="TextureRect" parent="."]
visible = false
margin_left = -6.0
margin_top = -8.0
margin_right = 1294.0
margin_bottom = 742.0
texture = ExtResource( 7 )
expand = true

[node name="warpedSpace" type="TextureRect" parent="."]
visible = false
material = SubResource( 3 )
margin_left = -24.0
margin_top = -16.0
margin_right = 1314.0
margin_bottom = 754.0
texture = ExtResource( 9 )
expand = true

[node name="shader3" type="TextureRect" parent="."]
visible = false
material = SubResource( 4 )
margin_left = -24.0
margin_top = -31.4544
margin_right = 1314.0
margin_bottom = 738.546
texture = ExtResource( 9 )
expand = true

[node name="AbstractTunnelEffect" type="TextureRect" parent="."]
visible = false
material = SubResource( 4 )
margin_left = -5.0
margin_top = 6.0
margin_right = 1272.0
margin_bottom = 725.0
texture = ExtResource( 9 )
expand = true

[node name="laserWaves2" type="TextureRect" parent="."]
visible = false
material = SubResource( 6 )
margin_left = 3.0
margin_top = 5.0
margin_right = 1275.0
margin_bottom = 722.0
texture = ExtResource( 9 )
expand = true

[node name="FogShader" type="TextureRect" parent="."]
visible = false
modulate = Color( 1, 1, 1, 0.501961 )
material = SubResource( 7 )
margin_left = -24.0
margin_top = -16.0
margin_right = 1314.0
margin_bottom = 754.0
texture = ExtResource( 9 )
expand = true

[node name="ShaderTemplate" type="Node2D" parent="."]
editor/display_folded = true
visible = false
script = ExtResource( 12 )

[node name="shaderTexture" type="TextureRect" parent="ShaderTemplate"]
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="rainbowSmoke" type="Node2D" parent="."]
editor/display_folded = true
visible = false
script = ExtResource( 12 )

[node name="shaderTexture" type="TextureRect" parent="rainbowSmoke"]
material = SubResource( 9 )
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="lightningWorld" type="Node2D" parent="."]
editor/display_folded = true
visible = false
script = ExtResource( 12 )

[node name="shaderTexture" type="TextureRect" parent="lightningWorld"]
material = SubResource( 11 )
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="backBufferTest" type="Node2D" parent="."]
editor/display_folded = true
visible = false
script = ExtResource( 12 )

[node name="BackBufferCopy3" type="BackBufferCopy" parent="backBufferTest"]
visible = false
material = SubResource( 13 )
position = Vector2( 641.45, 292.76 )
scale = Vector2( 6.37957, 3.04053 )

[node name="shaderTexture" type="TextureRect" parent="backBufferTest/BackBufferCopy3"]
visible = false
material = SubResource( 15 )
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="BackBufferCopy" type="BackBufferCopy" parent="backBufferTest"]
position = Vector2( 639.972, 360.053 )
scale = Vector2( 6.40071, 3.60378 )

[node name="texture" type="TextureRect" parent="backBufferTest/BackBufferCopy"]
material = SubResource( 17 )
margin_left = -100.0
margin_top = -100.0
margin_right = 100.0
margin_bottom = 100.0
texture = ExtResource( 14 )
expand = true

[node name="BackBufferCopy2" type="BackBufferCopy" parent="backBufferTest"]
position = Vector2( 639.972, 360.053 )
scale = Vector2( 6.40071, 3.60378 )

[node name="texture2" type="TextureRect" parent="backBufferTest/BackBufferCopy2"]
material = SubResource( 19 )
margin_left = -100.0
margin_top = -100.0
margin_right = 100.0
margin_bottom = 100.0
texture = ExtResource( 14 )
expand = true

[node name="plasmaRing" type="Node2D" parent="."]
editor/display_folded = true
visible = false
script = ExtResource( 12 )

[node name="shaderTexture" type="TextureRect" parent="plasmaRing"]
material = SubResource( 21 )
margin_left = -2.0
margin_top = 4.33801
margin_right = 1282.0
margin_bottom = 727.338
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="PlasmaBalll2" type="Node2D" parent="."]
editor/display_folded = true
visible = false
script = ExtResource( 12 )

[node name="shaderTexture" type="TextureRect" parent="PlasmaBalll2"]
material = SubResource( 23 )
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="SpiralsOfSpirals" type="Node2D" parent="."]
editor/display_folded = true
visible = false

[node name="shaderTexture" type="TextureRect" parent="SpiralsOfSpirals"]
material = SubResource( 25 )
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true
script = ExtResource( 13 )

[node name="DacingLasers" type="Node2D" parent="."]
editor/display_folded = true
visible = false

[node name="shaderTexture" type="TextureRect" parent="DacingLasers"]
material = SubResource( 27 )
margin_left = -2.0
margin_top = -2.0
margin_right = 1282.0
margin_bottom = 721.0
texture = ExtResource( 9 )
expand = true

[node name="laserWaves3" type="TextureRect" parent="DacingLasers/shaderTexture"]
visible = false
material = SubResource( 6 )
margin_left = 5.0
margin_top = 7.0
margin_right = 1277.0
margin_bottom = 724.0
texture = ExtResource( 9 )
expand = true

[node name="SpetraEffect" type="Node2D" parent="."]
editor/display_folded = true
visible = false

[node name="Sprite" type="Sprite" parent="SpetraEffect"]
material = SubResource( 28 )
position = Vector2( 638.235, 358.255 )
scale = Vector2( 20.9448, 12.1955 )
texture = ExtResource( 15 )

[node name="Sprite2" type="Sprite" parent="SpetraEffect"]
material = SubResource( 30 )
position = Vector2( 638.235, 358.255 )
scale = Vector2( 20.9448, 12.1955 )
texture = ExtResource( 15 )

[node name="PlasmaBall" type="Node2D" parent="."]
editor/display_folded = true
visible = false
position = Vector2( -1087.45, 1540.37 )
scale = Vector2( 41.0752, 23.2105 )

[node name="Sprite" type="Sprite" parent="PlasmaBall"]
material = SubResource( 32 )
position = Vector2( 42.1927, -50.6795 )
scale = Vector2( 0.490914, 0.493806 )
texture = ExtResource( 15 )

[node name="DJZoom" type="Node2D" parent="."]
editor/display_folded = true
visible = false

[node name="Buffer A" type="Sprite" parent="DJZoom"]
material = SubResource( 34 )
position = Vector2( 636.292, 374.925 )
scale = Vector2( 40.0923, 22.6866 )
texture = ExtResource( 16 )

[node name="Image" type="Sprite" parent="DJZoom"]
material = SubResource( 36 )
position = Vector2( -1087.45, 1540.37 )
scale = Vector2( 41.0752, 23.2105 )
texture = ExtResource( 16 )
offset = Vector2( 42.0641, -50.67 )

[node name="Viewport" type="Viewport" parent="DJZoom"]

[node name="circleShader" type="TextureRect" parent="."]
visible = false
material = SubResource( 37 )
margin_left = 6.0
margin_top = 29.0
margin_right = 3023.0
margin_bottom = 1559.0
texture = ExtResource( 9 )
expand = true

[node name="circleShader2" type="TextureRect" parent="."]
visible = false
material = SubResource( 37 )
margin_right = 1358.0
margin_bottom = 766.0
texture = ExtResource( 9 )
expand = true
